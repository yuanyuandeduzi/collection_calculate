package 动态规划;

/*
*       题目：一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：
*       ‘A’ -> 1    ‘B’->2  …… ‘Z’->26
*       要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。
*       输入：s = "12"
*       输出：2
*       解释：它可以解码为 "AB"（1 2）或者 "L"（12）。
*
*       输入：s = "226"
*       输出：3
*       解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
* */


/*
*       题解：定义dp数组记录到达当前位解码出的字符串的数量，由于0，没有与之匹配的解码字符串，所以需要对零进行特殊判断
*       初始化dp[0] = 1;由于是成员变量，所以余下至被初始化位0.下面从一开始遍历字符串，在循环内对当前位dp数组进行两次
*       修改判断，第一次判断当前位是否位零，若不为零则dp[i] += dp[i-1];否则则不进行操作
*               第二次判断上一位是否为零，若不为零，则接着判断是否能与当前位解码位一个字符，若能则 dp[i] += dp[i - 2];
*               否则则不进行操作
*       最后返回dp[n];
* */
public class Code_91解码方式 {
    public int numDecodings(String s) {
        int n = s.length();
        int[] dp = new int[n + 1];
        dp[0] = 1;
        for (int i = 1; i <= n; ++i) {
            if (s.charAt(i - 1) != '0') {
                dp[i] += dp[i - 1];
            }
            if (i > 1 && s.charAt(i - 2) != '0' && ((s.charAt(i - 2) - '0') * 10 + (s.charAt(i - 1) - '0') <= 26)) {
                dp[i] += dp[i - 2];
            }
        }
        return dp[n];
    }
}
