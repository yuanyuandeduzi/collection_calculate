package 动态规划;

/*
*       题目：给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。
*       请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。
*       假设每一种面额的硬币有无限个。 题目数据保证结果符合 32 位带符号整数。
*
*       输入：amount = 5, coins = [1, 2, 5]
*       输出：4
*       解释：有四种方式可以凑成总金额：
*       5=5
*       5=2+2+1
*       5=2+1+1+1
*       5=1+1+1+1+1
*
*       输入：amount = 3, coins = [2]
*       输出：0
*       解释：只用面额 2 的硬币不能凑成总金额 3 。
* */

/*
*       题解：定义dp数组记录组成当前钱数所能存在的组合方式，初始化dp数组，dp[0] = 1,表示钱数为0，只能由不放钱一种方式组成，
*       其他dp数组更新为0，dp数组更新，我们先用最小的钱数去更新dp数组，更新方式为 dp[i] += dp[i - coin];(添加这枚硬币
*       所能增加的种类数为钱数 i - coin的种类数)，为什么先用小硬币维护dp数组，应为大的硬币可通过对小的硬币进行替换实现种类
*       数一个更新。最后在返回dp[amount].
* */


public class Code_518零钱兑换II {
    public int change(int amount, int[] coins) {
        int max = amount + 1;
        int[] dp = new int[max];
        dp[0] = 1;
        for(int coin : coins) {
            for(int i = coin; i <= amount; i++) {       //因为只有当前钱数大于硬币大小时才有可能发生替换，对之前的
                dp[i] += dp[i - coin];                  //种类数产生影响
            }
        }
        return dp[amount];
    }
}
