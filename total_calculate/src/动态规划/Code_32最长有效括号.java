package 动态规划;

/**
*       题目：给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。
 *      输入：s = "(()"
 *      输出：2
 *      解释：最长有效括号子串是 "()"
 *      输入：s = ")()())"
 *      输出：4
 *      解释：最长有效括号子串是 "()()"
 * */


/*
*       题解：定义dp数组用于记录当前位置i,以i为结束位置的能匹配的括号字串的长度，对于括号匹配我们发现，有效的子串一定以 \text{‘)’}‘)’ 结尾，
*       所以遇见右括号时才会更新dp值，dp数组初始化为0，遍历字符串，若当前位i为‘）’，则有：
*       1.s[i - 1]为‘（’，则此时s[i - 1] 与 s[i]构成一对有效括号，此时字符串形式形如“……()”，
*           推出 dp[i] = dp[i - 2] + 2;表示第i - 2位的括号长度加上新匹配的一堆括号；
*       2.s[i - 1]为‘）’，此时字符串形如 “……))”，如果 s[i - dp[i - 1] - 1] = ‘(’
*           可以推出 dp[i]=dp[i−1]+2+dp[i−dp[i−1]−2];
*           形如："()(())"，对于上字符串有，dp[1] = 2, dp[4] = 2;此时i = 5，s[i]为‘）’，且s[i - 1]也为‘）‘，此时我们就需要判断
*       s[2](i - dp[i - 1] - 1 = 2)是否为’（‘，即dp[i - 1]表示的有效括号在新的括号中间，所以我们将前一有效括号长度跳过判断它的前一位
*       是否能匹配上，若能则dp[i] = dp[i - 1] + 2.但此时我们还需要考虑第i - dp[i - 1] - 2位的有效括号常度，因为它可与后面括号相连,所以
*       需要在加上dp[i - dp[i - 1] - 2]。
*       定义maxlength记录最大值，每次dp更新时维护最大值，然后就是对i-2，i - dp[i - 1] - 2的边界判断。
* */

public class Code_32最长有效括号 {
    public int longestValidParentheses(String s) {
        int length = s.length();
        int maxLength = 0;
        int[] dp = new int[length];
        for(int i = 1; i < length; i++) {
            if(s.charAt(i) == ')') {
                if(s.charAt(i - 1) == '(') {
                    dp[i] = (i - 2 >= 0 ? dp[i - 2] : 0) + 2;
                }else if(i - dp[i - 1] - 1 >= 0 && s.charAt(i - dp[i - 1] - 1) == '(') {
                    dp[i] = dp[i - 1] + 2 + (i - dp[i - 1] - 2 >= 1 ? dp[i - dp[i - 1] - 2] : 0);
                }
                maxLength = Math.max(maxLength, dp[i]);
            }
        }
        return maxLength;
    }
}
