package 数组;

/**
*       题目：初始时有n个灯泡处于关闭状态。
 *      对某个灯泡切换开关意味着：如果灯泡状态为关闭，那该灯泡就会被开启；而灯泡状态为开启，那该灯泡就会被关闭。
 *      第 1 轮，每个灯泡切换一次开关。即，打开所有的灯泡。
 *      第 2 轮，每两个灯泡切换一次开关。 即，每两个灯泡关闭一个。
 *      第 3 轮，每三个灯泡切换一次开关。
 *      第i 轮，每i个灯泡切换一次开关。 而第n轮，你只切换最后一个灯泡的开关。
 *      找出n轮后有多少个亮着的灯泡。
*/

/*
*       题解：我的 定义数组arr用于记录每个灯泡的状态，两层循环，外层循环遍历趟数，内层循环将以当前数值的整倍数的灯的状态转换，
*       前面可以定义一个ans用于记录亮着的灯泡的个数，初始化为0，若遇灯泡状态转换为亮则自加，反之自减。超内存，所以未过。
*           官方  我们对每一位的灯泡分析，我们会发现，若其的因数为奇数个，那么在最终的灯泡的状态将是亮的，若其因数的个数
*       为偶数，则灯泡状态为灭，所以我们可以通过判断这些灯泡中因数个数为奇数的个数，由于完全平方数的因数个数是奇数，非完全平方
*       数因数个数为偶数。所以问题再次转换为判断当前灯泡位置是不是完全平方数，定义ans，统计灯泡中位置为完全平方数的个数。
* */

public class Code_319灯泡开关 {

    public int bulbSwitchG(int n) {
        int ans = 0;
        for(int i = 1; i * i <= n; i++) {
            ans++;
        }
        return ans;
    }

    public int bulbSwitchM(int n) {
        int[] flag = new int[n+1];
        int ans = 0;
        for(int i = 1; i <= n; i++) {
            for(int j = i; j <= n; j += i) {
                if(flag[j] == 0) {
                    flag[j] = 1;
                    ans++;
                }else {
                    flag[j] = 0;
                    ans--;
                }
            }
        }
        return ans;
    }
}
